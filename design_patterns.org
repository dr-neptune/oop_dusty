#+TITLE: Python Design Patterns 1 & 2

In this chapter(s), we will see:
- Specific design patterns
- A canonical implementation of each pattern in Python
- Python syntax to replace certain patterns

* The Decorator Pattern

The decorator pattern allows us to wrap an object that provides core functionality with other objects that alter this functionality.

The two primary uses of the decorator pattern:
- Enhancing the response of a component as it sends data to a second component
- Supporting multiple optional behaviors

The second option is often a suitable alternative to multiple inheritance.

* A Decorator Example

#+BEGIN_SRC python :tangle inbound.py
########################################################################################
# Waits for a connection from a client and then prompts the user for a string response #
########################################################################################
import socket
from urllib.request import HTTPPasswordMgr
from decs import LogSocket

def respond(client):
    response = input("Enter a value: ")
    client.send(bytes(response, "utf8"))
    client.close()


server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(("localhost", 2401))
server.listen(1)


try:
    while True:
        client, addr = server.accept()
        # hypothetical config file
        # if log_send:
        #     client = LogSocket(client)
        # if client.getpeername()[0] in compress_hosts:
        #     client = GzipSocket(client)
        respond(LogSocket(client))
finally:
    server.close()
#+END_SRC

#+BEGIN_SRC python :tangle outbound.py
###############################################################################
#                Connects to port 2401 and outputs the response               #
###############################################################################
import socket
import decs

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(("localhost", 2401))
print(f"Received:\t{client.recv(1024)}")
client.close()
#+END_SRC

We will create a pair of decorators that customize the socket behavior without having to extend or modify the socket itself.

#+BEGIN_SRC python :tangle decs.py
###############################################################################
#                            Decorators for Sockets                           #
###############################################################################
import gzip
from io import BytesIO


class LogSocket:
    # Creates a log of the data sent to a peer ################################
    def __init__(self, socket):
        self.socket = socket

    def send(self, data):
        print(f"Sending {data} to {self.socket.getpeername()[0]}")
        self.socket.send(data)

    def close(self):
        self.socket.close()


class GzipSocket:
    # compresses the incoming data before sending it on the the client ########
    def __init__(self, socket):
        self.socket = socket

    def send(self, data):
        buf = BytesIO()
        zipfile = gzip.GzipFile(fileobj=buf, mode="w")
        zipfile.write(data)
        zipfile.close()
        self.socket.send(buf.getvalue())

    def close(self):
        self.socket.close()
#+END_SRC

* Decorators in Python

#+BEGIN_SRC python
import time

def log_calls(func):
    def wrapper(*args, **kwargs):
        now = time.time()
        print(f"Calling {func.__name__} with {args} and {kwargs}")
        return_value = func(*args, **kwargs)
        print(f"Executed {func.__name__} in {time.time() - now} ms")
        return return_value
    return wrapper

def test1(a, b, c):
    print("\ttest1 called")

def test2(a, b):
    print("\ttest2 called")

def test3(a, b):
    print("\ttest3 called")
    time.sleep(1)

t1, t2, t3 = log_calls(test1), log_calls(test2), log_calls(test3)

t1(1, 2, 3)
t2(4, b=5)
t3(6, 7)

# alternatively
@log_calls
def test4(a, b):
    print("\ttest4 called")

test4(8, 8)
#+END_SRC

* The Observer Pattern

The observer pattern is useful for state monitoring and event handling situations. This pattern allows a given object to be monitored by an unknown and dynamic group of observer objects.

* An Observer Example

#+BEGIN_SRC python
class Inventory:
    def __init__(self):
        self.observers = []
        self._product = None
        self._quantity = 0

    def attach(self, observer):
        self.observers.append(observer)

    @property
    def product(self):
        return self._product

    @product.setter
    def product(self, value):
        self._product = value
        self._update_observers()

    @property
    def quantity(self):
        return self._quantity

    @quantity.setter
    def quantity(self, value):
        self._quantity = value
        self._update_observers()

    def _update_observers(self):
        for observer in self.observers:
            observer()


# implement a simple observer object
class ConsoleObserver:
    def __init__(self, inventory):
        self.inventory = inventory

    def __call__(self):
        print(self.inventory.product)
        print(self.inventory.quantity)

i = Inventory()
c = ConsoleObserver(i)

i.attach(c)
i.product = "Widget"
i.quantity = 5

c1, c2 = ConsoleObserver(i), ConsoleObserver(i)
i.attach(c1)
i.attach(c2)
i.product = "Gadget"
#+END_SRC

* The Strategy Pattern

The pattern implements different solutions to a single problem, each in a different object. The client code can then choose the most appropriate implementation dynamically at runtime.

* A Strategy Example

We will build a desktop wallpaper manager

#+BEGIN_SRC python
from PIL import Image
from typing import Tuple

class TiledStrategy:
    def make_background(self, img_file: os.filePath, desktop_size: Tuple[int, int]):
        in_img = Image.open(img_file)
        out_img = Image.new("RGB", desktop_size)
        num_tiles = [
            o // i + 1 for o, i in zip(out_img.size, in_img.size)
        ]
        for x in range(num_tiles[1]):
            out_img.paste(
                in_img,
                (
                    in_img.size[0] * x,
                    in_img.size[1] * y,
                    in_img.size[0] * (x + 1),
                    in_img.size[1] * (y + 1)
                )
            )
        return out_img


class CenteredStrategy:
    def make_background(self, img_file, desktop_size):
        in_img = Image.open(img_file)
        out_img = Image.new("RGB", desktop_size)
        left = (out_img.size[0] - in_img.size[0]) // 2
        top = (out_img.size[1] - in_img.size[1]) // 2
        out_img.paste(
            in_img,
            (left, top, left + in_img.size[0], top + in_img.size[1]),
        )
        return out_img

class ScaledStrategy:
    def make_background(self, img_file, desktop_size):
        in_img = Image.open(img_file)
        out_img = in_img.resize(desktop_size)
        return out_img
#+END_SRC

* The State Pattern

The goal of the state pattern is to represent state-transition systems.


#+DOWNLOADED: /tmp/screenshot.png @ 2021-06-11 08:28:16
[[file:The State Pattern/screenshot_2021-06-11_08-28-16.png]]

* A state example

To illustrate the state pattern, we will build an xml parsing tool. The context class will be the parser itself.

#+BEGIN_SRC txt
<book>
  <author>Dusty Phillips</author>
  <publisher>Packt Publishing</publisher>
  <title>PyOOP</title>
  <content>
    <chapter>
      <number>1</number>
      <title>OOPity Scoop</title>
    </chapter>
    <chapter>
      <number>2</number>
      <title>Oop diddy woop</title>
    </chapter>
  </content>
</book>
#+END_SRC

We want the output of the program to be a tree of Node objects

#+DOWNLOADED: /tmp/screenshot.png @ 2021-06-11 08:35:40
[[file:A state example/screenshot_2021-06-11_08-35-40.png]]

#+BEGIN_SRC python :tangle xml_parser.py
class Node:
    def __init__(self, tag_name, parent=None):
        self.parent = parent
        self.tag_name = tag_name
        self.children = []
        self.text = ""

    def __str__(self):
        if self.text:
            return self.tag_name + ": " + self.text
        else:
            return self.tag_name


class Parser:
    def __init__(self, parse_string):
        self.parse_string = parse_string
        self.root = None
        self.current_node = None
        self.state = FirstTag()

    def process(self, remaining_string):
        remaining = self.state.process(remaining_string, self)
        if remaining:
            self.process(remaining)

    def start(self):
        self.process(self.parse_string)


class FirstTag:
    def process(self, remaining_string, parser):
        i_start_tag = remaining_string.find("<")
        i_end_tag = remaining_string.find(">")
        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]
        root = Node(tag_name)
        parser.root = parser.current_node = root
        parser.state = ChildNode()
        return remaining_string[i_end_tag + 1:]


class ChildNode:
    def process(self, remaining_string, parser):
        # remove whitespace from string
        stripped = remaining_string.strip()
        if stripped.startswith("</"):
            parser.state = CloseTag()
        elif stripped.startswith("<"):
            parser.state = OpenTag()
        else:
            parser.state = TextNode()
        return stripped


class OpenTag:
    def process(self, remaining_string, parser):
        i_start_tag = remaining_string.find("<")
        i_end_tag = remaining_string.find(">")
        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]
        node = Node(tag_name, parser.current_node)
        parser.current_node.children.append(node)
        parser.current_node = node
        parser.state = ChildNode()
        return remaining_string[i_end_tag + 1:]


class CloseTag:
    def process(self, remaining_string, parser):
        i_start_tag = remaining_string.find("<")
        i_end_tag = remaining_string.find(">")
        # assert remaining_string[i_start_tag + 1] == "/"
        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]
        # assert tag_name == parser.current_node.tag_name
        parser.current_node = parser.current_node.parent
        parser.state = ChildNode()
        return remaining_string[i_end_tag + 1 :].strip()


class TextNode:
    def process(self, remaining_string, parser):
        i_start_tag = remaining_string.find("<")
        text = remaining_string[:i_start_tag]
        parser.current_node.text = text
        parser.state = ChildNode()
        return remaining_string[i_start_tag:]


if __name__ == '__main__':
    import sys

    with open(sys.argv[1]) as file:
        contents = file.read()
        p = Parser(contents)
        p.start()

        nodes = [p.root]
        while nodes:
            node = nodes.pop(0)
            print(node)
            nodes = node.children + nodes
#+END_SRC

* State vs Strategy

The strategy pattern is used to choose an algorithm at runtime; generally only one of those algorithms is going to be chosen for a particular use case.

The state pattern is designed to allow switching between different states dynamically, as some process evolves.

* State transition as coroutines

This is totally doable.

* The Singleton Pattern

The basic idea behind the singleton pattern is to allow one instance of a certain object to exist.
Typically this is a sort of manager class. Such objects often need to be referenced by a wide variety of other objects. When a singleton is used, the separate objects request the single instance of the manager object from the class, so a reference need not be passed around.

* Singleton Implementation

Python doesn't have private constructors, but we can use the __new__ class method to ensure that only one instance is ever created.

#+BEGIN_SRC python

class OneOnly:
    _singleton = None
    def __new__(cls, *args, **kwargs):
        if not cls._singleton:
            cls._singleton = super(OneOnly, cls).__new__(cls, *args, **kwargs)
        return cls._singleton

o1 = OneOnly()
print(o1)
o2 = OneOnly()
print(o2)
print(o1 == o2)
#+END_SRC

* Module variables can mimic singletons

To use module-level variables instead of a singleton, we instantiate an instance of the class after we've defined it.

We can improve our state pattern to use singletons. Instead of creating a new object every time we change states, we can create a module level variable that is always accessible.

#+BEGIN_SRC python
# add all the state pattern code here
# Node
# FirstTag
# ChildNode
# OpenTag
# TextNode
# CloseTag

# then instantiate a module level variable for reuse
first_tag = FirstTag()
child_node = ChildNode()
text_node = TextNode()
open_tag = OpenTag()
close_tag = CloseTag()
#+END_SRC

* The Template Pattern

The template pattern is useful for removing duplicate code. It is designed for situations where we have several different tasks to accomplish that have some, but not all, steps in common. The common steps are implemented in a base class, and the distinct steps are overridden in subclasses to provide custom behavior.

* A Template Example

We will create a car sales reporter as an example.

We have two common tasks to perform:

- Select all sales of new vehicles and output them to the screen in a csv format
- Output a csv list of all salespeople with their gross sales and save it to a file that can be imported to a spreadsheet.

In both cases we need to:

1. Connect to the database
2. Construct a query for new vehicles or gross sales
3. Issue the query
4. Format the results into a comma delimited string
5. Output the data to a file or email

Before we start, let's create a database and put some sample data in it.

#+BEGIN_SRC python
import sqlite3

conn = sqlite3.connect("sales.db")

conn.execute("CREATE TABLE Sales (salesperson text, amt currency, year integer, model text, new boolean)")
conn.execute("INSERT INTO Sales values ('Tim', 9000, 2006, 'Ford Focus', 'false')")
conn.execute("INSERT INTO Sales values ('Tim', 16000, 2010, 'Honda Fit', 'true')")
conn.execute("INSERT INTO Sales values ('Gayle', 8000, 2004, 'Dodge Neon', 'false')")
conn.execute("INSERT INTO Sales values ('Gayle', 28000, 2009, 'Ford Mustang', 'true')")
conn.execute("INSERT INTO Sales values ('Gayle', 50000, 2010, 'Lincoln Navigator', 'true')")
conn.execute("INSERT INTO Sales values ('Don', 20000, 2008, 'Toyota Prius', 'false')")
conn.commit()
conn.close()
#+END_SRC

#+BEGIN_SRC python
import datetime as dt


class QueryTemplate:
    def connect(self):
        self.conn = sqlite3.connect("sales.db")

    def construct_query(self):
        """For use by a subclass"""
        raise NotImplementedError()

    def do_query(self):
        results = self.conn.execute(self.query)
        self.results = results.fetchall()

    def format_results(self):
        output = []
        for row in self.results:
            row = [str(i) for i in row]
            output.append(", ".join(row))
        self.formatted_results = "\n".join(output)

    def output_results(self):
        """For use by a subclass"""
        raise NotImplementedError()

    def process_format(self):
        self.connect()
        self.construct_query()
        self.do_query()
        self.format_results()
        self.output_results()


class NewVehiclesQuery(QueryTemplate):
    def construct_query(self):
        self.query = "select * from Sales where new='true'"

    def output_results(self):
        print(self.formatted_results)


class UserGrossQuery(QueryTemplate):
    def construct_query(self):
        self.query = ("select salesperson, sum(amt) from Sales group by salesperson")

    def output_results(self):
        filename = f"gross_sales_{dt.date.today().strftime('%Y%m%d')}"
        with open(filename, "w") as outfile:
            outfile.write(self.formatted_results)


new_vehicles = NewVehiclesQuery()
gross_user = UserGrossQuery()

print(gross_user.process_format())
print(new_vehicles.process_format())
#+END_SRC

Now onto chapter 11: Python Design Patterns II

* The Adapter Pattern

Adapters are used to allow two preexisting objects to work together, even if their interfaces are not compatible.

Decorators typically provide the same interface that they replace, whereas adapters map between two different interfaces.

#+BEGIN_SRC python
class AgeCalculator:
    def __init__(self, birthday):
        self.year, self.month, self.day = (int(x) for x in birthday.split("-"))

    def calculate_age(self, date):
        year, month, day = (int(x) for x in date.split("-"))
        age = year - self.year
        if (month, day) < (self.month, self.day):
            age -= 1
        return age
#+END_SRC

Instead of the above, we should use the datetime library. Instead of refactoring that, we could make an adaptor:

#+BEGIN_SRC python
import datetime

class DateAgeAdapter:
    def _str_date(self, date):
        return date.strftime("%Y-%m-%d")

    def __init__(self, birthday):
        birthday = self._str_date(birthday)
        self.calculator = AgeCalculator(birthday)

    def get_age(self, date):
        date = self._str_date(date)
        return self.calculator.calculate_age(date)
#+END_SRC

This adapter converts datetime.date and datetime.time into a string that our original AgeCalculator can use.

#+BEGIN_SRC python
# alternatively to the DateAgeAdapter
class AgreeableDate(datetime.date):
    def split(self, char):
        return self.year, self.month, self.day

bd = AgreeableDate(1975, 6, 14)
today = AgreeableDate.today()
print(today)

a = AgeCalculator(bd)
print(a.calculate_age(today))
#+END_SRC

* The Facade Pattern

The facade pattern is designed to provide a simple interface to a complex system of components.
It is, in many ways, like an adapter. The primary difference is that a facade tries to abstract a simpler interface out of a complex one, while an adapter only tries to map one existing interface to another.

#+BEGIN_SRC python
import smtplib
import imaplib

class EmailFacade:
    def __init__(self, host, username, password):
        self.host = host
        self.username = username
        self.password = password

    def send_email(self, to_email, subject, message):
        """Send an email"""
        if not "@" in self.username:
            from_email = f"{self.username}@{self.host}"
        else:
            from_email = self.username

        message = f"From: {from_email}\r\n To: {to_email}\r\n Subject: {subject}\r\n\r\n{message}"

        smtp = smtplib.SMTP(self.host)
        smtp.login(self.username, self.password)
        smtp.sendmail(from_email, [to_email], message)

    def get_inbox(self):
        """get messages in inbox"""
        mailbox = imaplib.IMAP4(self.host)
        mailbox.login(bytes(self.username, "utf8"),
                      bytes(self.password, "utf8"))
        mailbox.select()
        x, data = mailbox.search(None, "ALL")
        messages = []
        for num in data[0].split():
            x, message = mailbox.fetch(num, "(RFC822)")
            messages.append(message[0][1])
        return messages

woo = EmailFacade("localhost", "moop", "boop")

# needs an smtp connection
print(woo.send_email("yes@mailbox.org", "hi", "hello there"))
#+END_SRC

* The Flyweight Pattern
