#+TITLE: When to Use Object-Oriented Programming

In this chapter we will cover:
- How to recognize objects
- Data and behaviors
- Wrapping data behaviors using properties
- Restricting data using behaviors
- The Don't Repeat Yourself Principle
- Recognizing repeated code


* Treat Objects as Objects

Objects are things that have both data and behavior. If we are working only with data, we are often better of storing it in a data structure. If we are working only with behavior, but no stored data, a simple function is more suitable.

#+BEGIN_SRC python
# start with data
square = [(1, 1), (1, 2), (2, 2), (2, 1)]

# add functionality
import math

def distance(p1: int, p2: int) -> float:
    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)

def perimeter(polygon):
    perimeter = 0
    points = polygon + [polygon[0]]
    for i in range(len(polygon)):
        perimeter += distance(points[i], points[i + 1])
    return perimeter

# write a better perimeter function
# perimeter is the sum of the distances between two adjacent points in a polygon.
def perimeter(polygon):
    # add first and last
    perimeter = distance(polygon[0], polygon[-1])
    # add all pairwise distances
    for i in range(len(polygon) - 1):
        perimeter += distance(polygon[i], polygon[i + 1])
    return perimeter

# test functional api
print(perimeter(square))

# write OOP version
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def distance(self, p2):
        return math.sqrt((self.x - p2.x) ** 2 + (self.y - p2.y) ** 2)

class Polygon:
    def __init__(self):
        self.vertices = []

    def add_point(self, point):
        self.vertices.append((point))

    def perimeter(self):
        perimeter = 0
        points = self.vertices + [self.vertices[0]]
        for i in range(len(self.vertices)):
            perimeter += points[i].distance(points[i+1])
        return perimeter

square = Polygon()
square.add_point(Point(1, 1))
square.add_point(Point(1, 2))
square.add_point(Point(2, 2))
square.add_point(Point(2, 1))
print(square.perimeter())

# we can make the OO Polygon API as easy to use as the functional implementation
# all we need to do is allow it to be constructed with multiple points
class Polygon:
    def __init__(self, points=None):
        points = points if points else []
        self.vertices = [Point(*point) for point in points if isinstance(point, tuple)]

    def perimeter(self):
        # add first and last
        perimeter = self.vertices[0].distance(self.vertices[-1])
        # add all pairwise distances
        for i in range(len(self.vertices) - 1):
            perimeter += self.vertices[i].distance(self.vertices[i + 1])
        return perimeter



square = Polygon([(1, 1), (1, 2), (2, 2), (2, 1)])
print([i for i in square.vertices])
print(square.perimeter())
#+END_SRC

* Adding Behaviors to Class Data with Properties

Python gives us the property keyword to make methods that look like attributes.

#+BEGIN_SRC python
class Color:
    def __init__(self, rgb_value, name):
        self.rgb_value = rgb_value
        self._name = name

    def _set_name(self, name):
        if not name:
            raise Exception("Invalid Name")
        self._name = name

    def _get_name(self):
        return self._name

    name = property(_get_name, _set_name)

c = Color("#0000ff", "bright red")
print(c.name)
c.name = "red"
print(c.name)
c.name = "" # throw exception
#+END_SRC

* Properties in Detail

Think of the property function as returning an object that proxies any requests to set or access the attribute value through the methods we have specified.

#+BEGIN_SRC python
class Silly:
    def _get_silly(self):
        print("You are getting silly")
        return self._silly

    def _set_silly(self, value):
        print(f"You are making silly {value}")
        self._silly = value

    def _del_silly(self):
        print("Woah, you killed silly!")
        del self._silly

    silly = property(_get_silly, _set_silly, _del_silly, "This is a silly property")

s = Silly()
s.silly = "funny"
print(s.silly)
del s.silly
help(Silly)
#+END_SRC

* Decorators - Another way to create properties


#+BEGIN_SRC python
class Foo:
    @property
    def foo(self):
        return "bar"

    @foo.setter
    def foo(self, value):
        self._foo = value


class Silly:
    @property
    def silly(self):
        """This is a silly property"""
        print("You are getting silly")
        return self._silly

    @silly.setter
    def silly(self, value):
        print(f"You are making silly {value}")
        self._silly = value

    @silly.deleter
    def silly(self):
        print("Woah, you killed silly!")
        del self._silly

s = Silly()
s.silly = "funny"
print(s.silly)
del s.silly
help(Silly)
#+END_SRC

* Deciding when to use properties

A common need for custom behavior is caching a value that is difficult to calculate or expensive to look up. The goal is to store the variable locally to avoid repeated calls to the expensive calculation.

We can do this with a custom getter on the property.

#+BEGIN_SRC python
from urllib.request import urlopen

class WebPage:
    def __init__(self, url):
        self.url = url
        self._content = None

    @property
    def content(self):
        if not self._content:
            print("Retrieving new page...")
            self._content = urlopen(self.url).read()
        return self._content

import time
webpage = WebPage("http://ccphillips.net")
now = time.time()
content1 = webpage.content
print(time.time() - now)
now = time.time()
content2 = webpage.content
print(time.time() - now)
print(content2 == content1)

# custom getters are also useful for attributes that need to be calculated on the fly,
# based on other attributes
class AverageList(list):
    @property
    def average(self):
        return sum(self) / len(self)

a = AverageList([1, 2, 3, 4])
print(a.average)
#+END_SRC

* Manager Objects
