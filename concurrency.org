#+TITLE: Concurrency

This chapter looks at:
- Threads
- Multiprocessing
- Futures
- AsyncIO

* Threads

#+BEGIN_SRC python :tangle threading_fun.py
from threading import Thread

class InputReader(Thread):
    def run(self):
        self.line_of_text = input()

print("Enter some text and press enter: ")
thread = InputReader()
thread.start()

count = result = 1
while thread.is_alive():
    result = count * count
    count += 1

print(f"calculated squares up to {count} * {count} = {result}")
print(f"while you typed {thread.line_of_text}")
#+END_SRC

#+BEGIN_SRC python :tangle thread_weather.py
from threading import Thread
import time
from urllib.request import urlopen
from xml.etree import ElementTree

CITIES = {
    "Charlottetown": ("PE", "s0000583"),
    "Edmonton": ("AB", "s0000045"),
    "Fredericton": ("NB", "s0000250"),
    "Halifax": ("NS", "s0000318"),
    "Iqaluit": ("NU", "s0000394"),
    "Qu√©bec City": ("QC", "s0000620"),
    "Regina": ("SK", "s0000788"),
    "St. John's": ("NL", "s0000280"),
    "Toronto": ("ON", "s0000458"),
    "Victoria": ("BC", "s0000775"),
    "Whitehorse": ("YT", "s0000825"),
    "Winnipeg": ("MB", "s0000193"),
    "Yellowknife": ("NT", "s0000366")
}

class TempGetter(Thread):
    def __init__(self, city):
        super().__init__()
        self.city = city
        self.province, self.code = CITIES[self.city]

    def run(self):
        url = (
            "http://dd.weatheroffice.ec.gc.ca/citypage_weather/xml/"
            f"{self.province}/{self.code}_e.xml"
        )
        with urlopen(url) as stream:
            xml = ElementTree.parse(stream)
            self.temperature = xml.find(
                "currentConditions/temperature"
            ).text

threads = [TempGetter(c) for c in CITIES]
start = time.time()
for thread in threads:
    thread.start()
for thread in threads:
    thread.join()
for thread in threads:
    print(f"it is {thread.temperature} degrees C in {thread.city}")

print(f"Got {len(threads)} temps in {time.time() - start} seconds")
#+END_SRC

* Multiprocessing

The multithreading module spins up a new OS process to do the work.

This means that there is an entirely separate Python interpreter running for each process.

#+BEGIN_SRC python :tangle multi_p.py
from multiprocessing import Process, cpu_count
from threading import Thread
import time
import os

class MuchCPU(Thread):
    def run(self):
        print(os.getpid())
        for i in range(200000000):
            pass

if __name__ == '__main__':
    procs = [MuchCPU() for f in range(cpu_count())]
    t = time.time()
    for p in procs:
        p.start()
    for p in procs:
        p.join()
    print(f"work took {time.time() - t} seconds")
#+END_SRC

* Multiprocessing Pools

It might make sense to create at most cpu_count() processes when the program starts and then have them execute tasks as needed.
This has much less overhead than starting a new process for each task.
