#+TITLE: Strings and Serialization

In this chapter we focus on one of Python's most common objects: the string.

We'll look at:
- The complexities of strings, bytes, and byte arrays
- The ins and outs of string formatting
- A few ways to serialize data
- Regular expressions

* String Manipulation

#+BEGIN_SRC python
print(dir(str))

s = "hello world"
print(s.count("l"))
print(s.find("l"))
print(s.rindex("l"))
print(s.replace("l", "m"))
print(s.partition(" "))
#+END_SRC

* String Formatting

#+BEGIN_SRC python
orders = [("beyond burger", 14, 22), ("fries", 4, 89), ("something hoppy", 7, 19)]

print("\nPRODUCT \tQUANTITY \tPRICE \t\tSUBTOTAL")
for product, price, quantity in orders:
    subtotal = price * quantity
    print(
        f"{product:10s}\t{quantity: ^9d}\t"
        f"${price: <8.2f}\t${subtotal: >7.2f}"
    )
#+END_SRC

* Mutable byte strings

The bytes type is immutable.

#+BEGIN_SRC python
b = bytearray(b"abcdefgh")

b[4:6] = b"\x15\xa3"
print(b)
#+END_SRC

* Regular Expressions

** Matching Patterns

#+BEGIN_SRC python
import re

search_string = "hello world"
pattern = "hello world"
print(re.match(pattern, search_string))
#+END_SRC

The author uses the script below. I'll be using a function instead

#+BEGIN_SRC python :tangle regex_matcher.py
import sys
import re

pattern = sys.argv[1]
search_string = sys.argv[2]
match = re.match(pattern, search_string)

if match:
    print(f"'{search_string}' matches pattern '{pattern}'")
else:
    print(f"'{search_string}' does not match pattern '{pattern}'")
#+END_SRC

#+BEGIN_SRC python

def check_match(pattern, string="hello world"):
    regex = re.match(pattern, string)
    if regex:
        print(f"'{string}' matches pattern '{pattern}'")
        return regex
    else:
        print(f"'{string}' does not match pattern '{pattern}'")


# general
check_match("hello worl")

# string beginning and end
check_match("^hello")
check_match(".*world$")

# character classes
check_match("hel[lm]o world")

# escaping characters
check_match("0\.[0-9]{2}", "0.05")
check_match("\s\d\w", " 1a")

# matching multiple characters
check_match("hel*o")
check_match("hel+o")
check_match("[a-z]+")

# grouping patterns
check_match("abc{3}", "abccc")
check_match("[A-Z][a-z]*( [a-z]+)*\.$", "A good meal.")

# extracting information
match = check_match("^[a-zA-Z.]+@([a-z.]*\.[a-z]+)$", "some.user@example.com")

print(match.group())
print(match.groups()[0])

# findall
print(re.findall("a.", "abacadefagah"))
print(re.findall("a(.)", "abacadefgah"))
print(re.findall("(a)(.)", "abacadefgah"))

# make regex efficient with compile
regex = re.compile("a.")
print(re.findall(regex, "abaracadabara"))
#+END_SRC

* Filesystem Paths

#+BEGIN_SRC python
import os
import pathlib

# os way
print(path := os.path.abspath(os.sep.join([".", "subdir", "subsubdir"])))

# pathlib
path = (pathlib.Path(".") / "subdir" / "subsubdir" / "file.ext").absolute()
print(path)

# count the number of LOC excluding whitespace and comments in
# all python files in the current directory and subdirectory
def count_sloc(dir_path):
    sloc = 0
    for path in dir_path.iterdir():
        if path.name.startswith("."):
            continue
        if path.is_dir():
            sloc += count_sloc(path)
            continue
        if path.suffix != ".py":
            continue
        with path.open() as file:
            for line in file:
                line = line.strip()
                if line and not line.startswith("#"):
                    sloc += 1
    return sloc

# get working directory
root_path = pathlib.Path(".")
print(f"{count_sloc(root_path)} lines of python code")
#+END_SRC

* Serializing Objects

#+BEGIN_SRC python
import pickle

some_data = ["a list", "containing", 5, "values including another list", ["inner", "list"]]

# write
with open("pickled_list", "wb") as file:
    pickle.dump(some_data, file)

# read
with open("pickled_list", "rb") as file:
    loaded_data = pickle.load(file)

print(loaded_data)
print(loaded_data == some_data)
#+END_SRC

* Customizing Pickles

If an attribute is unpicklable, it usually has something to do with time sensitive attributes that it would not make sense to load in the future.
For example, an open network socket, open file, running thread, or database connection.

#+BEGIN_SRC python
# load contents of a web page every hour
from threading import Timer
import datetime
from urllib.request import urlopen

class UpdatedURL:
    def __init__(self, url):
        self.url = url
        self.contents = ""
        self.last_updated = None
        self.update()

    def update(self):
        self.contents = urlopen(self.url).read()
        self.last_updated = datetime.datetime.now()
        self.schedule()

    def schedule(self):
        self.timer = Timer(3600, self.update)
        self.timer.setDaemon(True)
        self.timer.start()
#+END_SRC
