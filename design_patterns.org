#+TITLE: Python Design Patterns 1 & 2

In this chapter(s), we will see:
- Specific design patterns
- A canonical implementation of each pattern in Python
- Python syntax to replace certain patterns

* The Decorator Pattern

The decorator pattern allows us to wrap an object that provides core functionality with other objects that alter this functionality.

The two primary uses of the decorator pattern:
- Enhancing the response of a component as it sends data to a second component
- Supporting multiple optional behaviors

The second option is often a suitable alternative to multiple inheritance.

* A Decorator Example

#+BEGIN_SRC python :tangle inbound.py
########################################################################################
# Waits for a connection from a client and then prompts the user for a string response #
########################################################################################
import socket
from decs import LogSocket

def respond(client):
    response = input("Enter a value: ")
    client.send(bytes(response, "utf8"))
    client.close()


server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(("localhost", 2401))
server.listen(1)


try:
    while True:
        client, addr = server.accept()
        # hypothetical config file
        # if log_send:
        #     client = LogSocket(client)
        # if client.getpeername()[0] in compress_hosts:
        #     client = GzipSocket(client)
        respond(LogSocket(client))
finally:
    server.close()
#+END_SRC

#+BEGIN_SRC python :tangle outbound.py
###############################################################################
#                Connects to port 2401 and outputs the response               #
###############################################################################
import socket
import decs

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(("localhost", 2401))
print(f"Received:\t{client.recv(1024)}")
client.close()
#+END_SRC

We will create a pair of decorators that customize the socket behavior without having to extend or modify the socket itself.

#+BEGIN_SRC python :tangle decs.py
###############################################################################
#                            Decorators for Sockets                           #
###############################################################################
import gzip
from io import BytesIO


class LogSocket:
    # Creates a log of the data sent to a peer ################################
    def __init__(self, socket):
        self.socket = socket

    def send(self, data):
        print(f"Sending {data} to {self.socket.getpeername()[0]}")
        self.socket.send(data)

    def close(self):
        self.socket.close()


class GzipSocket:
    # compresses the incoming data before sending it on the the client ########
    def __init__(self, socket):
        self.socket = socket

    def send(self, data):
        buf = BytesIO()
        zipfile = gzip.GzipFile(fileobj=buf, mode="w")
        zipfile.write(data)
        zipfile.close()
        self.socket.send(buf.getvalue())

    def close(self):
        self.socket.close()
#+END_SRC

* Decorators in Python

#+BEGIN_SRC python
import time

def log_calls(func):
    def wrapper(*args, **kwargs):
        now = time.time()
        print(f"Calling {func.__name__} with {args} and {kwargs}")
        return_value = func(*args, **kwargs)
        print(f"Executed {func.__name__} in {time.time() - now} ms")
        return return_value
    return wrapper

def test1(a, b, c):
    print("\ttest1 called")

def test2(a, b):
    print("\ttest2 called")

def test3(a, b):
    print("\ttest3 called")
    time.sleep(1)

t1, t2, t3 = log_calls(test1), log_calls(test2), log_calls(test3)

t1(1, 2, 3)
t2(4, b=5)
t3(6, 7)

# alternatively
@log_calls
def test4(a, b):
    print("\ttest4 called")

test4(8, 8)
#+END_SRC

* The Observer Pattern

The observer pattern is useful for state monitoring and event handling situations. This pattern allows a given object to be monitored by an unknown and dynamic group of observer objects.

* An Observer Example

#+BEGIN_SRC python
class Inventory:
    def __init__(self):
        self.observers = []
        self._product = None
        self._quantity = 0

    def attach(self, observer):
        self.observers.append(observer)

    @property
    def product(self):
        return self._product

    @product.setter
    def product(self, value):
        self._product = value
        self._update_observers()

    @property
    def quantity(self):
        return self._quantity

    @quantity.setter
    def quantity(self, value):
        self._quantity = value
        self._update_observers()

    def _update_observers(self):
        for observer in self.observers:
            observer()


# implement a simple observer object
class ConsoleObserver:
    def __init__(self, inventory):
        self.inventory = inventory

    def __call__(self):
        print(self.inventory.product)
        print(self.inventory.quantity)

i = Inventory()
c = ConsoleObserver(i)

i.attach(c)
i.product = "Widget"
i.quantity = 5

c1, c2 = ConsoleObserver(i), ConsoleObserver(i)
i.attach(c1)
i.attach(c2)
i.product = "Gadget"
#+END_SRC

* The Strategy Pattern

The pattern implements different solutions to a single problem, each in a different object. The client code can then choose the most appropriate implementation dynamically at runtime.

* A Strategy Example

We will build a desktop wallpaper manager

#+BEGIN_SRC python
from PIL import Image
from typing import Tuple

class TiledStrategy:
    def make_background(self, img_file: os.filePath, desktop_size: Tuple[int, int]):
        in_img = Image.open(img_file)
        out_img = Image.new("RGB", desktop_size)
        num_tiles = [
            o // i + 1 for o, i in zip(out_img.size, in_img.size)
        ]
        for x in range(num_tiles[1]):
            out_img.paste(
                in_img,
                (
                    in_img.size[0] * x,
                    in_img.size[1] * y,
                    in_img.size[0] * (x + 1),
                    in_img.size[1] * (y + 1)
                )
            )
        return out_img


class CenteredStrategy:
    def make_background(self, img_file, desktop_size):
        in_img = Image.open(img_file)
        out_img = Image.new("RGB", desktop_size)
        left = (out_img.size[0] - in_img.size[0]) // 2
        top = (out_img.size[1] - in_img.size[1]) // 2
        out_img.paste(
            in_img,
            (left, top, left + in_img.size[0], top + in_img.size[1]),
        )
        return out_img

class ScaledStrategy:
    def make_background(self, img_file, desktop_size):
        in_img = Image.open(img_file)
        out_img = in_img.resize(desktop_size)
        return out_img
#+END_SRC

* The State Pattern

The goal of the state pattern is to represent state-transition systems.


#+DOWNLOADED: /tmp/screenshot.png @ 2021-06-11 08:28:16
[[file:The State Pattern/screenshot_2021-06-11_08-28-16.png]]

* A state example

To illustrate the state pattern, we will build an xml parsing tool. The context class will be the parser itself.

#+BEGIN_SRC txt
<book>
  <author>Dusty Phillips</author>
  <publisher>Packt Publishing</publisher>
  <title>PyOOP</title>
  <content>
    <chapter>
      <number>1</number>
      <title>OOPity Scoop</title>
    </chapter>
    <chapter>
      <number>2</number>
      <title>Oop diddy woop</title>
    </chapter>
  </content>
</book>
#+END_SRC

We want the output of the program to be a tree of Node objects

#+DOWNLOADED: /tmp/screenshot.png @ 2021-06-11 08:35:40
[[file:A state example/screenshot_2021-06-11_08-35-40.png]]

#+BEGIN_SRC python :tangle xml_parser.py
class Node:
    def __init__(self, tag_name, parent=None):
        self.parent = parent
        self.tag_name = tag_name
        self.children = []
        self.text = ""

    def __str__(self):
        if self.text:
            return self.tag_name + ": " + self.text
        else:
            return self.tag_name


class Parser:
    def __init__(self, parse_string):
        self.parse_string = parse_string
        self.root = None
        self.current_node = None
        self.state = FirstTag()

    def process(self, remaining_string):
        remaining = self.state.process(remaining_string, self)
        if remaining:
            self.process(remaining)

    def start(self):
        self.process(self.parse_string)


class FirstTag:
    def process(self, remaining_string, parser):
        i_start_tag = remaining_string.find("<")
        i_end_tag = remaining_string.find(">")
        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]
        root = Node(tag_name)
        parser.root = parser.current_node = root
        parser.state = ChildNode()
        return remaining_string[i_end_tag + 1:]


class ChildNode:
    def process(self, remaining_string, parser):
        # remove whitespace from string
        stripped = remaining_string.strip()
        if stripped.startswith("</"):
            parser.state = CloseTag()
        elif stripped.startswith("<"):
            parser.state = OpenTag()
        else:
            parser.state = TextNode()
        return stripped


class OpenTag:
    def process(self, remaining_string, parser):
        i_start_tag = remaining_string.find("<")
        i_end_tag = remaining_string.find(">")
        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]
        node = Node(tag_name, parser.current_node)
        parser.current_node.children.append(node)
        parser.current_node = node
        parser.state = ChildNode()
        return remaining_string[i_end_tag + 1:]


class CloseTag:
    def process(self, remaining_string, parser):
        i_start_tag = remaining_string.find("<")
        i_end_tag = remaining_string.find(">")
        # assert remaining_string[i_start_tag + 1] == "/"
        tag_name = remaining_string[i_start_tag + 1 : i_end_tag]
        # assert tag_name == parser.current_node.tag_name
        parser.current_node = parser.current_node.parent
        parser.state = ChildNode()
        return remaining_string[i_end_tag + 1 :].strip()


class TextNode:
    def process(self, remaining_string, parser):
        i_start_tag = remaining_string.find("<")
        text = remaining_string[:i_start_tag]
        parser.current_node.text = text
        parser.state = ChildNode()
        return remaining_string[i_start_tag:]


if __name__ == '__main__':
    import sys

    with open(sys.argv[1]) as file:
        contents = file.read()
        p = Parser(contents)
        p.start()

        nodes = [p.root]
        while nodes:
            node = nodes.pop(0)
            print(node)
            nodes = node.children + nodes
#+END_SRC

* State vs Strategy

The strategy pattern is used to choose an algorithm at runtime; generally only one of those algorithms is going to be chosen for a particular use case.

The state pattern is designed to allow switching between different states dynamically, as some process evolves.

* State transition as coroutines

This is totally doable.

* The Singleton Pattern
