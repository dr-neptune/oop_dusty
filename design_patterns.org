#+TITLE: Python Design Patterns 1 & 2

In this chapter(s), we will see:
- Specific design patterns
- A canonical implementation of each pattern in Python
- Python syntax to replace certain patterns

* The Decorator Pattern

The decorator pattern allows us to wrap an object that provides core functionality with other objects that alter this functionality.

The two primary uses of the decorator pattern:
- Enhancing the response of a component as it sends data to a second component
- Supporting multiple optional behaviors

The second option is often a suitable alternative to multiple inheritance.

* A Decorator Example

#+BEGIN_SRC python :tangle inbound.py
########################################################################################
# Waits for a connection from a client and then prompts the user for a string response #
########################################################################################
import socket
from decs import LogSocket

def respond(client):
    response = input("Enter a value: ")
    client.send(bytes(response, "utf8"))
    client.close()


server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(("localhost", 2401))
server.listen(1)


try:
    while True:
        client, addr = server.accept()
        # hypothetical config file
        # if log_send:
        #     client = LogSocket(client)
        # if client.getpeername()[0] in compress_hosts:
        #     client = GzipSocket(client)
        respond(LogSocket(client))
finally:
    server.close()
#+END_SRC

#+BEGIN_SRC python :tangle outbound.py
###############################################################################
#                Connects to port 2401 and outputs the response               #
###############################################################################
import socket
import decs

client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
client.connect(("localhost", 2401))
print(f"Received:\t{client.recv(1024)}")
client.close()
#+END_SRC

We will create a pair of decorators that customize the socket behavior without having to extend or modify the socket itself.

#+BEGIN_SRC python :tangle decs.py
###############################################################################
#                            Decorators for Sockets                           #
###############################################################################
import gzip
from io import BytesIO


class LogSocket:
    # Creates a log of the data sent to a peer ################################
    def __init__(self, socket):
        self.socket = socket

    def send(self, data):
        print(f"Sending {data} to {self.socket.getpeername()[0]}")
        self.socket.send(data)

    def close(self):
        self.socket.close()


class GzipSocket:
    # compresses the incoming data before sending it on the the client ########
    def __init__(self, socket):
        self.socket = socket

    def send(self, data):
        buf = BytesIO()
        zipfile = gzip.GzipFile(fileobj=buf, mode="w")
        zipfile.write(data)
        zipfile.close()
        self.socket.send(buf.getvalue())

    def close(self):
        self.socket.close()
#+END_SRC

* Decorators in Python

#+BEGIN_SRC python
import time

def log_calls(func):
    def wrapper(*args, **kwargs):
        now = time.time()
        print(f"Calling {func.__name__} with {args} and {kwargs}")
        return_value = func(*args, **kwargs)
        print(f"Executed {func.__name__} in {time.time() - now} ms")
        return return_value
    return wrapper

def test1(a, b, c):
    print("\ttest1 called")

def test2(a, b):
    print("\ttest2 called")

def test3(a, b):
    print("\ttest3 called")
    time.sleep(1)

t1, t2, t3 = log_calls(test1), log_calls(test2), log_calls(test3)

t1(1, 2, 3)
t2(4, b=5)
t3(6, 7)

# alternatively
@log_calls
def test4(a, b):
    print("\ttest4 called")

test4(8, 8)
#+END_SRC

* The Observer Pattern

The observer pattern is useful for state monitoring and event handling situations. This pattern allows a given object to be monitored by an unknown and dynamic group of observer objects.

* An Observer Example

#+BEGIN_SRC python
class Inventory:
    def __init__(self):
        self.observers = []
        self._product = None
        self._quantity = 0

    def attach(self, observer):
        self.observers.append(observer)

    @property
    def product(self):
        return self._product

    @product.setter
    def product(self, value):
        self._product = value
        self._update_observers()

    @property
    def quantity(self):
        return self._quantity

    @quantity.setter
    def quantity(self, value):
        self._quantity = value
        self._update_observers()

    def _update_observers(self):
        for observer in self.observers:
            observer()


# implement a simple observer object
class ConsoleObserver:
    def __init__(self, inventory):
        self.inventory = inventory

    def __call__(self):
        print(self.inventory.product)
        print(self.inventory.quantity)

i = Inventory()
c = ConsoleObserver(i)

i.attach(c)
i.product = "Widget"
i.quantity = 5

c1, c2 = ConsoleObserver(i), ConsoleObserver(i)
i.attach(c1)
i.attach(c2)
i.product = "Gadget"
#+END_SRC

* The Strategy Pattern
